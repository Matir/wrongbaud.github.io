---
layout: post
title:  "Hardware Debugging for Reverse Engineers Part 2: JTAG, SSDs and Firmware Extraction"
image: ''
date:   2020-03-23 00:06:31
tags:
- hardware
- reversing
- jtag
description: ''
categories:
- hardware
- reversing
---

# Background
To follow up my [last post](https://wrongbaud.github.io/stm-xbox-jtag/) about SWD and hardware debugging, I wanted to do a _pseudo_ deep dive into JTAG from a reverse engineering perspective. The previous post recieved a lot of great feedback and it seems that people are interested in this topic, so I wanted to continue the series and expand upon another hardware debugging mechanism. For those who are unfamiliar, JTAG is another hardware level debugging mechanism that many embedded CPUs utilize, with this post I hope to explain how to approach JTAG from a reverse engineers perspective and provide some practical examples along the way.

## Goals

With this post, I hope to do the following:

1.) Explain how JTAG works
2.) Demonstrate how to enumerate and utilize a JTAG port/interface on an unknown target
3.) Provide an overview of some of the current OSS tools that can be used to interact with a JTAG interface 
4.) Utilize JTAG to extract firmware and debug a target 

Also, before I give an overview, I wanted to point out a few great resources for learning about JTAG

* [Cyphunk's Embedded Analysis Page](https://github.com/cyphunk/JTAGenum/wiki/Embedded-Analysis#jtag)
* [FPGA4Fun JTAG Overview](https://www.fpga4fun.com/JTAG.html)
* [Blackbox JTAG Reverse Engineering](https://pdfs.semanticscholar.org/69ac/07f94832ceb4d2344c9c2d2bc8fc04e68124.pdf?_ga=2.81325524.238759085.1584580795-2049975628.1584580795)

## JTAG Overview

JTAG is a hardware interface that was developed to assist developers and testers with low level debugging. JTAG was originally developed for testing integrated circuits and more specifically, sampling IO pins on a target under test. This type of debugging interface allows engineers to test connections on PCBs without needing the probe the physical pin itself. The JTAG interface is controlled via the state machine outlined below:

![JTAG State Machine](http://openocd.org/doc-release/doxygen/jtag-state-machine-large.png)

A JTAG interface consists of the following lines:

| Line | Usage |
| ---- | ----- |
| TMS | This pin is used to navigate and control the JTAG state machine |
| TDI | Used to output data to the target and write to registers | 
| TDO | Used to read data back out from the target |
| TCK | Used to determine when data is sampled for all inputs and outputs | 
| TRST (Optional) | This pin can be used to reset the state machine to the starting state | 

The state machine is navigated using the TMS and TCK lines, while data is written to or read from via TDI and TDO respectively. TMS is sampled on the rising edge of TCK, meaning that the TMS line must be asserted before TCK is toggled in order to navigate through the state machine. 

JTAG was designed to allow for multiple chips to be daisy chained together by linking TDO/TDI registers as seen below:

![JTAG Daisy Chain](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c9/Jtag_chain.svg/654px-Jtag_chain.svg.png)

At a low level, the JTAG peripheral is interfaced with by writing to the instruction and data register (IR/DR). 

### JTAG Registers

JTAG utilizes two main registers, the instruction register, and the data register. The instruction register is used to determine what function the JTAG controller is about to carry out such as a memory read, or memory write for example. The data registers are then used as additional inputs to the instruction register, for the previous example they may be used to provide and address to read from or write to. These registers can vary in size based on their function, 

In order to write to a register one would perform the following steps, we'll use the IR as an example:

1. Enter Test Logic Reset (TLR)
2. ```Select IR Scan```
3. ```Capture IR```
4. ```Shift IR``` -- This is where we load the data into IR from TDI
5. ``` Exit IR```
6. ``` Update IR``` -- This stage "latches" the value into IR, for example, if we had loaded the ```IDCODE``` register into IR, this would load the IDCODE into ```TDO``` for us to then clock out and read it on ```TDO``.

#### Instruction Registers

The JTAG standard defines a few instruction registers that are mandatory:

* ```BYPASS```
* ```IDCODE```

The default state of the scan chain typically loads the ```IDCODE``` register, allowing 
## Locating Possible JTAG Headers

JTAG lines are often grouped together - so when looking at a new platform from a hardware perspective, looking for pin groupings greater than 5 is always a good start. Luckily for us on this target, there are 9 vias located along the outside of the PCB. Let's start by examining the voltage levels of these pins with the drive in a normal operating state

| Pin | Voltage Level | Usage | 
| --- | ------------- | ----- |
| 1 |  0.1 V | ??? |
| 2 |  1.8 V | ??? |
| 3 |  0.1 V | ??? |
| 4 |  0.1 V | ??? |
| 5 |  0.1 V | ??? |
| 6 |  0.1 V | ??? |
| 7 |  GND | GND |
| 8 |  1.8 V | ??? |
| 9 |  1.8 V | ??? |

From a first pass - these voltage values don't really tell us anything, so what can we determine based on the information we have? First off, we have a GND which is an easy one to determine by using continuity mode on the multimeter and testing against something like a shield of the USB connector (while the target is unplugged of course!). Next we have one line at 1.8V, typically one would expect this to be TMS as it is reccomended to be held high in most documentation.

Also, very important to note here that the logic levels are at 1.8V so we will need to use a logic level shifter if we're going to interface to this target with an FT2232H or Raspberry PI [TODO: ADD LINKS]


### Determining the pinout

Running the script wired up as shown below yields a TON of results, the output can be seen [here].

This is not really surprising, we would rather have too many than none. But how do we filter through these? Luickily, the IDs are typically standardized so we can google the IDs until we find one that recognize. Luckily in this list there is an ID that I have seen before: ```0x4ba00477```  - this ID is for an ARM Cortex core and I've seen it before when attempting to get access to [Beaglebone Black]().

```
ntrst:pin3 tck:pin1 tms:pin2 tdo:pin6 tdi:pin4  devices: 1
0x4ba00477
ntrst:pin3 tck:pin1 tms:pin2 tdo:pin6 tdi:pin5  devices: 1
0x4ba00477
ntrst:pin4 tck:pin1 tms:pin2 tdo:pin6 tdi:pin3  devices: 1
0x4ba00477
ntrst:pin4 tck:pin1 tms:pin2 tdo:pin6 tdi:pin5  devices: 1
0x4ba00477
ntrst:pin5 tck:pin1 tms:pin2 tdo:pin6 tdi:pin3  devices: 1
0x4ba00477
ntrst:pin5 tck:pin1 tms:pin2 tdo:pin6 tdi:pin4  devices: 1
0x4ba00477
```

| Pin | Voltage Level | Usage | 
| --- | ------------- | ----- |
| 1 |  0.1 | ??? |
| 2 |  1.8 | Maybe VCC |
| 3 |  0.1 | ??? |
| 4 |  0.1 | ??? |
| 5 |  0.1 | ??? |
| 6 |  0.1 | ??? |
| 7 |  GND | GND |
| 8 |  1.8 | ??? |
| 9 |  1.8 | ??? |

Running the regular scan results in the following:

```
pi@raspberrypi:~/JTAGenum $ sudo ./JTAGenum.sh 
Results will not be saved to a file!
================================
Starting scan for pattern: 0110011101001101101000010111001001
active  ntrst:pin3 tck:pin1 tms:pin2 tdo:pin6 tdi:pin4 bits toggled:3
active  ntrst:pin3 tck:pin1 tms:pin2 tdo:pin6 tdi:pin5 bits toggled:3
active  ntrst:pin3 tck:pin1 tms:pin4 tdo:pin6 tdi:pin2 bits toggled:15
active  ntrst:pin3 tck:pin1 tms:pin5 tdo:pin6 tdi:pin2 bits toggled:15
FOUND!  ntrst:pin4 tck:pin1 tms:pin2 tdo:pin6 tdi:pin3 IR length: 4
active  ntrst:pin4 tck:pin1 tms:pin2 tdo:pin6 tdi:pin5 bits toggled:3
active  ntrst:pin4 tck:pin1 tms:pin3 tdo:pin6 tdi:pin2 bits toggled:15
active  ntrst:pin4 tck:pin1 tms:pin5 tdo:pin6 tdi:pin2 bits toggled:15
FOUND!  ntrst:pin5 tck:pin1 tms:pin2 tdo:pin6 tdi:pin3 IR length: 4
active  ntrst:pin5 tck:pin1 tms:pin2 tdo:pin6 tdi:pin4 bits toggled:3
active  ntrst:pin5 tck:pin1 tms:pin3 tdo:pin6 tdi:pin2 bits toggled:15
active  ntrst:pin5 tck:pin1 tms:pin4 tdo:pin6 tdi:pin2 bits toggled:15
================================
```

## JTAG Debugging via OpenOCD

### Adapters: JTAG via SYSFS 

### Adapters: JTAG via FT2232H 

## JTAG Debugging via JLink

## Conclusion
